// Copyright 2021 IBM Corp
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package _import

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/IBM/go-sdk-core/v4/core"
	rcv2 "github.com/IBM/platform-services-go-sdk/resourcecontrollerv2"
	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/klog/v2"

	"github.com/ppc64le-cloud/pvsadm/pkg"
	"github.com/ppc64le-cloud/pvsadm/pkg/client"
	"github.com/ppc64le-cloud/pvsadm/pkg/utils"
)

const (
	serviceCredPrefix = "pvsadm-service-cred"
)

var Cmd = &cobra.Command{
	Use:   "import",
	Short: "Import the image into PowerVS instances",
	Long: `Import the image into PowerVS instances
pvsadm image import --help for information

# Set the API key or feed the --api-key commandline argument
export IBMCLOUD_API_KEY=<IBM_CLOUD_API_KEY>

Examples:

# import image using default storage type (service credential will be autogenerated)
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# import image using default storage type with specifying the accesskey and secretkey explicitly
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --accesskey <ACCESSKEY> --secretkey <SECRETKEY> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# with user provided storage type
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --pvs-storagetype <STORAGETYPE> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# If user wants to specify the type of OS
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --object rhel-83-10032020.ova.gz --pvs-image-name test-image --ostype <OSTYPE> -r <REGION>
`,
	PreRunE: func(cmd *cobra.Command, args []string) error {
		if pkg.ImageCMDOptions.InstanceID == "" && pkg.ImageCMDOptions.InstanceName == "" {
			return fmt.Errorf("--pvs-instance-name or --pvs-instance-id required")
		}
		return nil
	},

	RunE: func(cmd *cobra.Command, args []string) error {
		var s3client *client.S3Client
		opt := pkg.ImageCMDOptions
		apikey := pkg.Options.APIKey
		//validate inputs
		validOsType := []string{"aix", "ibmi", "redhat", "sles"}
		validStorageType := []string{"tier3", "tier1"}

		if opt.OsType != "" && !utils.Contains(validOsType, strings.ToLower(opt.OsType)) {
			klog.Errorf("Provide valid OsType.. allowable values are [aix, ibmi, redhat, sles]")
			os.Exit(1)
		}

		if !utils.Contains(validStorageType, strings.ToLower(opt.StorageType)) {
			klog.Errorf("Provide valid StorageType.. allowable values are [tier1, tier3]")
			os.Exit(1)
		}

		bxCli, err := client.NewClientWithEnv(apikey, pkg.Options.Environment, pkg.Options.Debug)

		if err != nil {
			return err
		}

		auth, err := core.NewIamAuthenticator(apikey, "", "", "", false, nil)
		if err != nil {
			return err
		}

		resourceController, err := client.NewResourceControllerV2(&rcv2.ResourceControllerV2Options{
			Authenticator: auth,
		})
		if err != nil {
			return err
		}

		serviceListOptions := resourceController.ResourceControllerV2.NewListResourceInstancesOptions().SetType("service_instance")
		if opt.COSInstanceName != "" {
			serviceListOptions.SetName(opt.COSInstanceName)
		}
		instances, _, err := resourceController.ResourceControllerV2.ListResourceInstances(serviceListOptions)
		if err != nil {
			return err
		}

		// Step 1: Find where COS for the bucket
		cosOfBucket := func(resources []rcv2.ResourceInstance) *rcv2.ResourceInstance {
			for _, resource := range resources {
				if strings.Contains(*resource.Crn, "cloud-object-storage") {
					s3client, err = client.NewS3Client(bxCli, *resource.Name, opt.Region)
					if err != nil {
						continue
					}
					buckets, err := s3client.S3Session.ListBuckets(nil)
					if err != nil {
						continue
					}
					for _, bucket := range buckets.Buckets {
						if *bucket.Name == opt.BucketName {
							return &resource
						}
					}
				}
			}
			return nil
		}(instances.Resources)

		if cosOfBucket == nil {
			return fmt.Errorf("failed to find the COS instance for the bucket mentioned: %s", opt.BucketName)
		}
		klog.Infof("%s bucket found in the %s[ID:%s] COS instance", opt.BucketName, *cosOfBucket.Name, *cosOfBucket.ID)

		//Step 2: Check if s3 object exists
		objectExists := s3client.CheckIfObjectExists(opt.BucketName, opt.ImageFilename)
		if !objectExists {
			return fmt.Errorf("failed to found the object %s in %s bucket", opt.ImageFilename, opt.BucketName)
		}
		klog.Infof("%s object found in the %s bucket\n", opt.ImageFilename, opt.BucketName)

		if opt.AccessKey == "" || opt.SecretKey == "" {
			// Step 3: Check if Service Credential exists for the found COS instance

			// frame the unique name for the service credential
			if opt.ServiceCredName == "" {
				opt.ServiceCredName = serviceCredPrefix + "-" + *cosOfBucket.Name
			}

			keys, err := resourceController.ListResourceKeysBySourceCrn(opt.ServiceCredName, *cosOfBucket.Crn)
			if err != nil {
				return fmt.Errorf("failed to list the service credentials: %v", err)
			}

			cred := new(rcv2.Credentials)
			if len(keys) == 0 {
				// Create the service credential if does not exist
				klog.Infof("Auto Generating the COS Service credential for importing the image with name: %s", opt.ServiceCredName)
				createResourceKeyOptions := &client.CreateResourceKeyOptions{
					CreateResourceKeyOptions: resourceController.ResourceControllerV2.NewCreateResourceKeyOptions(opt.ServiceCredName, *cosOfBucket.ID),
					Parameters:               map[string]interface{}{"HMAC": true},
				}

				key, _, err := resourceController.CreateResourceKey(createResourceKeyOptions)
				if err != nil {
					return err
				}
				cred = key.Credentials
			} else {
				// Use the service credential already created
				klog.Infof("Reading the existing service credential: %s", opt.ServiceCredName)
				cred = keys[0].Credentials
			}

			jsonString, err := json.Marshal(cred.GetProperty("cos_hmac_keys"))
			if err != nil {
				return err
			}
			h := struct {
				AccessKeyID string `json:"access_key_id"`
				SecretKeyID string `json:"secret_access_key"`
			}{}
			err = json.Unmarshal(jsonString, &h)
			if err != nil {
				klog.Errorf("failed to unmarshal the access credentials from the auto generated service credential")
				return err
			}

			// Step 4: Assign the Access Key and Secret Key for further operation
			opt.AccessKey = h.AccessKeyID
			opt.SecretKey = h.SecretKeyID

		}

		pvmclient, err := client.NewPVMClientWithEnv(bxCli, opt.InstanceID, opt.InstanceName, pkg.Options.Environment)
		if err != nil {
			return err
		}

		image, err := pvmclient.ImgClient.ImportImage(pvmclient.InstanceID, opt.ImageName, opt.ImageFilename, opt.Region,
			opt.AccessKey, opt.SecretKey, opt.BucketName, strings.ToLower(opt.OsType), strings.ToLower(opt.StorageType))
		if err != nil {
			return err
		}

		if !opt.Watch {
			klog.Infof("Importing Image %s is currently in %s state, Please check the Progress in the IBM Cloud UI\n", *image.Name, image.State)
			return nil
		}

		start := time.Now()
		pollErr := wait.PollImmediate(2*time.Minute, opt.WatchTimeout, func() (bool, error) {
			img, err := pvmclient.ImgClient.Get(*image.ImageID)
			if err != nil {
				return false, err
			}
			if img.State == "active" {
				return true, nil
			}
			klog.Infof("Import in-progress, current state: %s", img.State)
			return false, nil
		})
		if pollErr == wait.ErrWaitTimeout {
			pollErr = fmt.Errorf("timed out while waiting for image to become ready state")
		}

		if pollErr != nil {
			return fmt.Errorf("failed to import the image, err: %v\n\nRun this command to get more information for the failure: pvsadm get events -i %s", pollErr, pvmclient.InstanceID)
		}

		klog.Infof("Successfully imported the image: %s with ID: %s within %s", *image.Name, *image.ImageID, time.Since(start))

		return nil
	},
}

func init() {
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.InstanceName, "pvs-instance-name", "n", "", "PowerVS Instance name.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.InstanceID, "pvs-instance-id", "i", "", "PowerVS Instance ID.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.BucketName, "bucket", "b", "", "Cloud Object Storage bucket name.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.COSInstanceName, "cos-instance-name", "s", "", "Cloud Object Storage instance name.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.Region, "bucket-region", "r", "", "Cloud Object Storage bucket location.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.ImageFilename, "object", "o", "", "Cloud Object Storage object name.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.AccessKey, "accesskey", "", "Cloud Object Storage HMAC access key.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.SecretKey, "secretkey", "", "Cloud Object Storage HMAC secret key.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.ImageName, "pvs-image-name", "", "Name to PowerVS imported image.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.OsType, "ostype", "redhat", "Image OS Type, accepted values are[aix, ibmi, redhat, sles].")
	Cmd.Flags().BoolVarP(&pkg.ImageCMDOptions.Watch, "watch", "w", false, "After image import watch for image to be published and ready to use")
	Cmd.Flags().DurationVar(&pkg.ImageCMDOptions.WatchTimeout, "watch-timeout", 1*time.Hour, "watch timeout")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.StorageType, "pvs-storagetype", "tier3", "PowerVS Storage type, accepted values are [tier1, tier3].")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.ServiceCredName, "cos-service-cred", "", "IBM COS Service Credential name to be auto generated(default \""+serviceCredPrefix+"-<COS Name>\")")

	_ = Cmd.MarkFlagRequired("bucket")
	_ = Cmd.MarkFlagRequired("bucket-region")
	_ = Cmd.MarkFlagRequired("pvs-image-name")
	_ = Cmd.MarkFlagRequired("object")
	Cmd.Flags().SortFlags = false
}
