package _import

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/IBM/go-sdk-core/v4/core"
	rcv2 "github.com/IBM/platform-services-go-sdk/resourcecontrollerv2"
	"github.com/spf13/cobra"
	"k8s.io/klog/v2"

	"github.com/ppc64le-cloud/pvsadm/pkg"
	"github.com/ppc64le-cloud/pvsadm/pkg/client"
	"github.com/ppc64le-cloud/pvsadm/pkg/utils"
)

const (
	ServiceCredName = "pvsadm-service-cred"
)

var Cmd = &cobra.Command{
	Use:   "import",
	Short: "Import the image into PowerVS instances",
	Long: `Import the image into PowerVS instances
pvsadm image import --help for information

# Set the API key or feed the --api-key commandline argument
export IBMCLOUD_API_KEY=<IBM_CLOUD_API_KEY>

Examples:

# import image using default storage type (service credential will be autogenerated)
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --object-name rhel-83-10032020.ova.gz --image-name test-image -r <REGION>

# import image using default storage type with specifying the accesskey and secretkey explicitly
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --accesskey <ACCESSKEY> --secretkey <SECRETKEY> --object-name rhel-83-10032020.ova.gz --image-name test-image -r <REGION>

# with user provided storage type
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> -r <REGION> --storagetype <STORAGETYPE> --object-name rhel-83-10032020.ova.gz --image-name test-image -r <REGION>

# If user wants to specify the type of OS
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --object-name rhel-83-10032020.ova.gz --image-name test-image --ostype <OSTYPE> -r <REGION>
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		opt := pkg.ImageCMDOptions
		apikey := pkg.Options.APIKey
		//validate inputs
		validOsType := []string{"aix", "ibmi", "redhat", "sles"}
		validStorageType := []string{"tier3", "tier1"}

		if opt.OsType != "" && !utils.Contains(validOsType, strings.ToLower(opt.OsType)) {
			klog.Errorf("Provide valid OsType.. allowable values are [aix, ibmi, redhat, sles]")
			os.Exit(1)
		}

		if !utils.Contains(validStorageType, strings.ToLower(opt.StorageType)) {
			klog.Errorf("Provide valid StorageType.. allowable values are [tier1, tier3]")
			os.Exit(1)
		}

		if opt.AccessKey == "" || opt.SecretKey == "" {
			klog.Info("Auto Generating the COS Service credential for importing the image")
			auth, err := core.NewIamAuthenticator(apikey, "", "", "", false, nil)
			if err != nil {
				return err
			}

			bxCli, err := client.NewClient(apikey)
			if err != nil {
				return err
			}

			resourceController, err := client.NewResourceControllerV2(&rcv2.ResourceControllerV2Options{
				Authenticator: auth,
			})
			if err != nil {
				return err
			}

			instances, _, err := resourceController.ResourceControllerV2.ListResourceInstances(resourceController.ResourceControllerV2.NewListResourceInstancesOptions().SetType("service_instance"))
			if err != nil {
				return err
			}

			// Step 1: Find where COS for the bucket
			cosOfBucket := func(resources []rcv2.ResourceInstance) *rcv2.ResourceInstance {
				for _, resource := range resources {
					if strings.Contains(*resource.Crn, "cloud-object-storage") {
						s3client, err := client.NewS3Client(bxCli, *resource.Name, opt.Region)
						if err != nil {
							continue
						}
						buckets, err := s3client.S3Session.ListBuckets(nil)
						if err != nil {
							continue
						}
						for _, bucket := range buckets.Buckets {
							if *bucket.Name == opt.BucketName {
								return &resource
							}
						}
					}
				}
				return nil
			}(instances.Resources)

			if cosOfBucket == nil {
				return fmt.Errorf("failed to find the COS instance for the bucket mentioned: %s", opt.BucketName)
			}
			klog.Infof("%s bucket found in the %s[ID:%s] COS instance", opt.BucketName, *cosOfBucket.Name, *cosOfBucket.ID)

			// Step 2: Create the Service Credential in the found COS instance
			createResourceKeyOptions := &client.CreateResourceKeyOptions{
				CreateResourceKeyOptions: resourceController.ResourceControllerV2.NewCreateResourceKeyOptions(ServiceCredName, *cosOfBucket.ID),
				Parameters:               map[string]interface{}{"HMAC": true},
			}

			key, _, err := resourceController.CreateResourceKey(createResourceKeyOptions)
			if err != nil {
				return err
			}
			defer resourceController.ResourceControllerV2.DeleteResourceKey(&rcv2.DeleteResourceKeyOptions{ID: key.ID})

			jsonString, err := json.Marshal(key.Credentials.GetProperty("cos_hmac_keys"))
			if err != nil {
				return err
			}
			h := struct {
				AccessKeyID string `json:"access_key_id"`
				SecretKeyID string `json:"secret_access_key"`
			}{}
			err = json.Unmarshal(jsonString, &h)
			if err != nil {
				klog.Errorf("failed to unmarshal the access credentials from the auto generated service credential")
				return err
			}

			// Step 3: Assign the Access Key and Secret Key for further operation
			opt.AccessKey = h.AccessKeyID
			opt.SecretKey = h.SecretKeyID
		}

		c, err := client.NewClient(apikey)
		if err != nil {
			return err
		}

		pvmclient, err := client.NewPVMClient(c, opt.InstanceID, opt.InstanceName)
		if err != nil {
			return err
		}

		image, err := pvmclient.ImgClient.ImportImage(pvmclient.InstanceID, opt.ImageName, opt.ImageFilename, opt.Region,
			opt.AccessKey, opt.SecretKey, opt.BucketName, strings.ToLower(opt.OsType), strings.ToLower(opt.StorageType))
		if err != nil {
			return err
		}

		klog.Infof("Importing Image %s is currently in %s state, Please check the Progress in the IBM Cloud UI\n", *image.Name, image.State)
		return nil
	},
}

func init() {
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.InstanceName, "instance-name", "n", "", "Instance name of the PowerVS")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.InstanceID, "instance-id", "i", "", "Instance ID of the PowerVS instance")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.BucketName, "bucket", "b", "", "Cloud Storage bucket name")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.Region, "region", "r", "", "Cloud Storage Region")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.AccessKey, "accesskey", "", "Cloud Storage access key")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.SecretKey, "secretkey", "", "Cloud Storage secret key")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.ImageName, "image-name", "", "Name to give imported image")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.ImageFilename, "object-name", "", "Cloud Storage image filename")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.OsType, "ostype", "redhat", "Image OS Type, accepted values are[aix, ibmi, redhat, sles]")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.StorageType, "storagetype", "tier3", "Storage type, accepted values are [tier1, tier3]")
	_ = Cmd.MarkFlagRequired("bucket")
	_ = Cmd.MarkFlagRequired("image-name")
	_ = Cmd.MarkFlagRequired("object-name")
	_ = Cmd.MarkFlagRequired("region")
}
